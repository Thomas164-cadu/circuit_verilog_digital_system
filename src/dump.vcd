$date
	Mon Mar 28 21:43:45 2022
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module testbench $end
$var wire 16 ! saida0 [15:0] $end
$var reg 16 " A0 [15:0] $end
$var reg 16 # B0 [15:0] $end
$var reg 16 $ C0 [15:0] $end
$var reg 1 % H0 $end
$var reg 1 & LH0 $end
$var reg 1 ' LS0 $end
$var reg 1 ( LX0 $end
$var reg 2 ) M00 [1:0] $end
$var reg 2 * M10 [1:0] $end
$var reg 2 + M20 [1:0] $end
$var reg 1 , clk0 $end
$var reg 1 - reset0 $end
$var reg 16 . x0 [15:0] $end
$scope module jose $end
$var wire 16 / A [15:0] $end
$var wire 16 0 B [15:0] $end
$var wire 16 1 C [15:0] $end
$var wire 1 % H $end
$var wire 1 & LH $end
$var wire 1 ' LS $end
$var wire 1 ( LX $end
$var wire 2 2 M0 [1:0] $end
$var wire 2 3 M1 [1:0] $end
$var wire 2 4 M2 [1:0] $end
$var wire 16 5 Pronto [15:0] $end
$var wire 1 , clk $end
$var wire 1 - rst $end
$var wire 16 6 x [15:0] $end
$var wire 16 7 saidaSM [15:0] $end
$var wire 16 8 saidaR2 [15:0] $end
$var wire 16 9 saidaR1 [15:0] $end
$var wire 16 : saidaR0 [15:0] $end
$var wire 16 ; saidaM2 [15:0] $end
$var wire 16 < saidaM1 [15:0] $end
$var wire 16 = saidaM0 [15:0] $end
$scope module R0 $end
$var wire 16 > D [15:0] $end
$var wire 16 ? Q [15:0] $end
$var wire 1 , clk $end
$var wire 1 ( load $end
$var wire 1 - rst $end
$var reg 16 @ saida [15:0] $end
$upscope $end
$scope module R1 $end
$var wire 16 A Q [15:0] $end
$var wire 1 , clk $end
$var wire 1 & load $end
$var wire 1 - rst $end
$var wire 16 B D [15:0] $end
$var reg 16 C saida [15:0] $end
$upscope $end
$scope module R2 $end
$var wire 1 , clk $end
$var wire 1 ' load $end
$var wire 1 - rst $end
$var wire 16 D Q [15:0] $end
$var wire 16 E D [15:0] $end
$var reg 16 F saida [15:0] $end
$upscope $end
$scope module ULA $end
$var wire 1 % H $end
$var wire 1 , clk $end
$var wire 16 G resultado [15:0] $end
$var wire 16 H xis [15:0] $end
$var wire 16 I abc [15:0] $end
$var reg 16 J r [15:0] $end
$upscope $end
$scope module multiplexador0 $end
$var wire 16 K A [15:0] $end
$var wire 16 L B [15:0] $end
$var wire 16 M C [15:0] $end
$var wire 16 N D [15:0] $end
$var wire 1 , clk $end
$var wire 16 O saidaM [15:0] $end
$var wire 2 P set [1:0] $end
$var reg 16 Q s [15:0] $end
$upscope $end
$scope module multiplexador1 $end
$var wire 16 R A [15:0] $end
$var wire 16 S B [15:0] $end
$var wire 16 T C [15:0] $end
$var wire 16 U D [15:0] $end
$var wire 1 , clk $end
$var wire 16 V saidaM [15:0] $end
$var wire 2 W set [1:0] $end
$var reg 16 X s [15:0] $end
$upscope $end
$scope module multiplexador2 $end
$var wire 16 Y A [15:0] $end
$var wire 16 Z B [15:0] $end
$var wire 16 [ C [15:0] $end
$var wire 16 \ D [15:0] $end
$var wire 1 , clk $end
$var wire 16 ] saidaM [15:0] $end
$var wire 2 ^ set [1:0] $end
$var reg 16 _ s [15:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx _
bx ^
bx ]
b0 \
b0 [
bx Z
b0 Y
bx X
bx W
bx V
b0 U
b0 T
b0 S
bx R
bx Q
bx P
bx O
b10 N
b10 M
b1 L
b0 K
bx J
bx I
bx H
bx G
b0 F
bx E
b0 D
b0 C
bx B
b0 A
b0 @
b0 ?
b10 >
bx =
bx <
bx ;
b0 :
b0 9
b0 8
bx 7
b10 6
b0 5
bx 4
bx 3
bx 2
b10 1
b10 0
b1 /
b10 .
1-
0,
bx +
bx *
bx )
0(
0'
0&
0%
b10 $
b10 #
b1 "
b0 !
$end
#1
0-
1,
#2
0,
#3
b10 :
b10 ?
b10 S
b10 Y
b10 @
b0 ;
b0 H
b0 ]
b0 _
b0 =
b0 O
b0 R
b0 Z
b0 Q
1,
b0 +
b0 4
b0 ^
b0 *
b0 3
b0 W
1(
b0 )
b0 2
b0 P
#4
0,
#5
b10 ;
b10 H
b10 ]
b10 _
b10 <
b10 I
b10 V
b10 X
1,
1%
b1 *
b1 3
b1 W
0(
#6
0,
#7
bx 9
bx A
bx U
bx \
bx C
b100 7
b100 B
b100 E
b100 G
b100 J
1,
1&
#8
0,
#9
b100 9
b100 A
b100 U
b100 \
b100 C
1,
